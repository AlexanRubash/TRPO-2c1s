Все числа в JavaScript хранятся в 64-битном формате IEEE-754, который также называют «числа с плавающей точкой двойной точности»


let billion = 1e9;  // 1 миллиард 
alert( 7.3e9 );  // 7.3 миллиардов
Другими словами, "e" производит операцию умножения числа на 1 с указанным количеством нулей.
1e3 = 1 * 1000
1.23e6 = 1.23 * 1000000

let ms = 0.000001;
Записать микросекунду в укороченном виде также можно с помощью "e".
let ms = 1e-6; // шесть нулей, слева от 1
1e-3 = 1 / 1000 (=0.001)  // -3 делится на 1 с 3 нулями

-------------------Шестнадцатеричные, двоичные и восьмеричные числа-------------------------------------

используются в JavaScript для представления цветов, кодировки символов и многое другое.
alert( 0xff ); // 255
alert( 0xFF ); // 255 (регистр не имеет значения)


let a = 0b11111111; // бинарная форма записи числа 255
let b = 0o377; // восьмеричная форма записи числа 255
alert( a == b ); // true 


-------------------toString(base)числа-------------------------------------
 Метод num.toString(base) возвращает строковое представление числа num в системе счисления base. Например:
let num = 255;
alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111

Значение base может варьироваться от 2 до 36 (по умолчанию 10):
-base = 16 – для шестнадцатеричного представления цвета, кодировки символов и т.д., цифры могут быть 0..9 или A..F.
-base = 2 – обычно используется для отладки побитовых операций, цифры 0 или 1.
-base = 36 – максимальное основание, цифры могут быть 0..9 или A..Z. То есть, используется весь латинский алфавит для представления числа. 

-------------------Округление-------------------------------------

-Math.floor – округление в меньшую сторону: 3.1 становится 3, а -1.1 – -2.
-Math.ceil – округление в большую сторону: 3.1 становится 4, а -1.1 – -1.
-Math.round – округление до ближайшего целого: 3.1 становится 3, 3.6 – 4, а -1.1 – -1.
-Math.trunc (не поддерживается в Internet Explorer) – производит удаление дробной части без округления: 3.1 становится 3, а -1.1 – -1.

Пример:
	Math.floor	Math.ceil	Math.round	Math.trunc
3.1	3		4		3		3
3.6	3		4		4		3
-1.1	-2		-1		-1		-1
-1.6	-2		-1		-2		-1

let n = 1.23456;
alert( n.toFixed(2) ); // 1.23

let num = 12.34;
alert( num.toFixed(5) ); // "12.34000"


------------------- Неточные вычисления-------------------------------------
Если число слишком большое, оно переполнит 64-битное хранилище, JavaScript вернёт бесконечность:
alert( 1e500 ); // Infinity

alert( 0.1 + 0.2 == 0.3 ); // false
alert( 0.1 + 0.2 ); // 0.30000000000000004
Так происходит потому, что число хранится в памяти в бинарной форме, как последовательность бит – единиц и нулей. Но дроби, такие как 0.1, 0.2, на самом деле 1/3, которая становится бесконечной дробью 0.33333(3).
let sum = 0.1 + 0.2;
alert( sum.toFixed(2) ); // 0.30
В других случаях можно использовать унарный оператор +, чтобы преобразовать строку в число:
alert( +sum.toFixed(2) ); // 0.3


------------------- Проверка: isFinite и isNaN-------------------------------------

Специальные числовые значения Infinity ( -Infinity) и NaN  принадлежат типу number, но они не являются «обычными» числами, поэтому есть функции для их проверки:

-isNaN(value) преобразует значение в число и проверяет является ли оно NaN:
alert( isNaN(NaN) ); // true
alert( isNaN("str") ); // true
Нельзя просто сравнить === NaN, так как значение NaN уникально тем, что оно не является равным ни чему другому, даже самому себе:
alert( NaN === NaN ); // false

-isFinite(value) преобразует аргумент в число и возвращает true, если оно является обычным числом, т.е. не NaN/Infinity/-Infinity:
alert( isFinite("15") ); // true
alert( isFinite("str") ); // false
alert( isFinite(Infinity) ); // false 

Иногда isFinite используется для проверки, содержится ли в строке число:
let num = +prompt("Enter a number", '');
alert( isFinite(num) );

------------------- Сравнение Object.is-------------------------------------

Object.is-сравнивает значения примерно как ===, но более надёжен в двух особых ситуациях:
1. Сравнивает NaN: Object.is(NaN, NaN) === true.
2. Значения 0 и -0 разные: Object.is(0, -0) === false, это редко используется, но технически эти значения разные.
Во всех других случаях Object.is(a, b) идентичен a === b.

----------------------parseInt и parseFloat----------------------------------

Для явного преобразования к числу можно использовать + или Number(). Если строка не является в точности числом, то результат будет NaN: alert( +"100px" ); // NaN

parseInt возвращает целое число, а parseFloat возвращает число с плавающей точкой.
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5
alert( parseInt('12.3') ); // 12 
alert( parseFloat('12.3.4') ); // 12.3 

Используется чтобы получить числовое значение из таких строк: "100px" или "12pt" в CSS, во множестве стран символ валюты записывается после номинала "19€". 

Функции parseInt/parseFloat вернут NaN, если не смогли прочитать ни одну цифру: alert( parseInt('a123') ); // NaN 


alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255 
alert( parseInt('2n9c', 36) ); // 123456

----------------------Другие математические функции----------------------------------

Math.random() – возвращает псевдослучайное число в диапазоне [0, 1)
alert( Math.random() ); // 0.1234567894322

Math.max(a, b, c...) / Math.min(a, b, c...) – возвращает наибольшее/наименьшее число из перечисленных аргументов.
alert( Math.max(3, 5, -10, 0, 1) ); // 5
alert( Math.min(1, 2) ); // 1

Math.pow(n, power) – возвращает число n, возведённое в степень power
alert( Math.pow(2, 10) ); // 2 в степени 10 = 1024


